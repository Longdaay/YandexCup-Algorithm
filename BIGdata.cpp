/* Задача D. Большие данные
*	Ограничение времени		1 секунда
*	Ограничение памяти		512Mb
*	Ввод					стандартный ввод или input.txt
*	Вывод					стандартный вывод или output.txt
* 
* Условие задачи:
* Даны массив a длины n, и массив b длины m. Все элементы обоих массивов — цифры от 0 до 9 включительно.
* Составим по этим массивам таблицу c размера n×m, где элемент в i-й строке и j-м столбце определяется формулой c_i,j = a_i * 10**9 + b_j.
* Рассмотрим всевозможные пути из клетки 1,1 в клетку c_n,m, состоящие только из перемещений вниз и вправо (то есть, из клетки c_i,j 
* можно переходить только в клетки c_i+1,j и c_i,j+1, если эти клетки находятся внутри таблицы). 
* Среди всех этих путей выберите такой, что сумма чисел в посещённых клетках максимальна, и выведите эту сумму.
* 
* Формат ввода:
* Первая строка содержит два целых числа n и m — размеры массивов a и b соответственно (1 ≤ n,m ≤ 100000).
* Во второй строке записано n целых чисел a_1,...,a_n (0 ≤ a_i ≤ 9).
* Во третьей строке записано m целых чисел b_1,...,b_m (0 ≤ b_j ≤ 9).

* Формат вывода:
* Выведите одно число — максимальную сумму чисел в клетках среди путей в таблице c, удовлетворяющих правилам выше.
*/

/*
* Логика построена на поиск в двух полученных массивах максимальных значений, строки и столбцы которых потенциально будут иметь
* максимальные элементы в матрице. Расчеты происходят на ходу, исходная матрица не формируется.
*/

#include <iostream>
#include <vector>
#include <fstream>
#include <math.h>
#include <set>

using namespace std;

class BigData {
public:
	BigData();
	vector < int> getVecFile(ifstream& in);
	long long int getSumm() { return summ; }
	void findmax();
	bool checkForEqual();
private:
	vector< int> a_vec; // 1 массив
	vector< int> b_vec; // 2 массив
	int a_vecSize;
	int b_vecSize;
	long long summ = 0; // максимальная найденная сумма
};

BigData::BigData() { // конструктор
	ifstream in; // объявляем поток для файла 
	in.open("input.txt"); // открываем файл
	in >> a_vecSize; // получем размер 1го массива
	in >> b_vecSize; // получем размер 2го массива
	a_vec = getVecFile(in); // получаем из файла 1 массив
	b_vec = getVecFile(in); // получаем из файла 2 массив
	in.close(); // поток закрываем
}

vector <int> BigData::getVecFile(ifstream& in) {	
	// получаем из файла массив чисел (на вход принимаем поток с файла) на выход отдаем массив чисел из файла
	vector< int> values_list; // массив в который запишем наши числа
	int tempValue; // переменная куда будут записываться числа из файла
	char t;	// символьная переменная	
	in >> tempValue;	// получаем первое число
	values_list.push_back(tempValue); // записываем его
	in.get(t); // считываем следующий символ в файле
	while (t != '\n') {  // пока эта переменная не получит символ конца строки продолжаем записывать числа в массив
		if (!in.eof()) { // если не достигли конца файла - записываем, иначе - символу присваиваем конец строки
			in >> tempValue;
			values_list.push_back(tempValue);
			in.get(t);
		}
		else
			t = '\n';
	}
	return values_list; // возвращаем массив
}

int maximum(vector<int>& value_list) {							
	// поиск максимального числа в массиве строк/столбцов. Возвращаем его индекс
	int maximumValue_in_list = value_list[0];// задаем максимуму - первое значение
	int iterator = 0;// переменная для вывода индекса максимума
	for (int i = 0; i < value_list.size(); i++) {//	
		if (value_list[i] > maximumValue_in_list) {// если текущ больше мах
			iterator = i;// записываем его индекс
			maximumValue_in_list = value_list[i];// записываем это число в мах
		}
	}
	return iterator;// возвращаем индекс
}

vector<int> getIndexMaxValues(vector<int>& value_list, int& indexMaxValue) {
	/*
	* в функции получаем индексы элементов с заданным максимальным значением. Необходимо для определения
	* индексов таких максимальных значений
	*/
	int maxValue_in_list = value_list[indexMaxValue];// присваиваем мах максимальное значение
	vector<int> vecIndexMaxValues;
	for (int i = 0; i < value_list.size(); i++) {// проходим по массиву и ищем максимальные значения 
		if (value_list[i] == maxValue_in_list)
			vecIndexMaxValues.push_back(i); // добавляем в массив
	}
	return vecIndexMaxValues; // возвращаем массив
}

bool BigData::checkForEqual() {
	/*
	* функция проверки матрицы на одинаковые значения. Необходима для отработки случая, когда все значения 
	* элементов равны. Для этого создается два неповторяющихся массива SET (по строкам и по столбцам) и в них
	* записыватся значения двух массивов. Если после выхода из записи количество элементов в SET'ах равно 1, то
	* это значит, что все значения элементов равны. True - значения равны. False - значения разные
	*/
	set<int> setEqualRow; // массив по строкам
	set<int>setEqualColumn; // массив по столбцам
	for (auto& token : a_vec) // проходим по массиву значений строк
		setEqualRow.insert(token); // пытаемся добавить элемент
	for (auto& token : b_vec) // проходим по массиву значений строк
		setEqualColumn.insert(token); // пытаемся добавить элемент
	if (setEqualRow.size() == 1 && setEqualColumn.size() == 1) // если размеры массивов = 1, то все значения в массивах одинковы
		return true;
	else
		return false;
}

void BigData::findmax() {
	/*
	* Основной алгоритм поиска максимальной суммы по матрице. 
	* Алгоритм заключается в следующем:
	*	Поиск максимального значения по двум массива
	*	Создание списка индексов элементов, где значения этих элементов равно масимальному
	*	Проверка матрицы на одинаковые значения
	*	Цикл прохода по индексам с максимальным значением и добавлением результата формулы в конечную сумму
	*	После прохода всех максимальных строк - последний проход до последнего элемента (в конец строки - в конец столбца : это самый максимальный путь)
	*/
	int StopColumn, StopRow; // переменные "строк/столбцов-ограничителей"
	vector<int> list_IndexStopRow;
	int i = 0; // строка
	int j = 0; // столбец
	/* Поиск максимального значения по двум массивам, а затем создание массива индексов элементов, 
	* значения которого равны этому максимальному значению для массива строк. Массив индексов
	* максимальных элементов необходим для определения строк с самыми большими значениями.
	*/
	StopColumn = maximum(b_vec); // поиск индекса для стобца
	StopRow = maximum(a_vec); // поиск индекса для строки
	list_IndexStopRow = getIndexMaxValues(a_vec, StopRow); // заполняем массив индексов максимальных значений
	if (checkForEqual()) {	// если все значения равны
		summ = (a_vec[i] * pow(10, 9) + b_vec[j]) * ((a_vec.size() + b_vec.size()) - 1); // вычисляем по формуле
		return; // выходим
	}
	for (int step = 0; step < list_IndexStopRow.size(); step++) { // идем по циклу строк, присваивая ограничителям строк индексы максимальных значений
		StopRow = list_IndexStopRow[step]; // присваиваем очередной индекс
		while (i != StopRow) { // пока не дошли до ограничителя строки
			summ += a_vec[i] * pow(10, 9) + b_vec[j]; // добавляем к сумме новое значение
			i++;
		}
		while (j != StopColumn) { // пока не дошли до ограничителя столбца
			summ += a_vec[i] * pow(10, 9) + b_vec[j]; // добавляем к сумме новое значение
			j++;
		}
	}
	list_IndexStopRow.clear();
	/*
	* Как только мы прошли все ограничители, самый максимальный путь будет до конца строки и до конца столбца.
	* Выглядеть будет следующим образом (0 - здесь указывает элемент, х - точка на которой остановились
	* 0	 0	0	0	0			* 0	 0	0	0	0
	* 0	 0	0	0	0			* 0	 0	0	0	0
	* 0	 0	x	0	0   ==>		* 0	 0	x	->	|
	* 0	 0	0	0	0			* 0	 0	0	0	|
	* 0	 0	0	0	0			* 0	 0	0	0	|
	*/
	if (StopColumn == j && StopRow == i) {
		while (j != b_vecSize) { // пока не дошли до последнего столбца
			summ += a_vec[i] * pow(10, 9) + b_vec[j]; // добавляем к сумме новое значение
			j++;
		}
		j--;
		i++;
		while (i != a_vecSize) { // пока не дошли до последнй строки
			summ += a_vec[i] * pow(10, 9) + b_vec[j]; // добавляем к сумме новое значение
			i++;
		}
		return;
	}
}

int main() {
	BigData bd; // экземпляр класса
	bd.findmax(); // поиск максимального
	cout << bd.getSumm(); // выводим сумму
	return 0;
}


